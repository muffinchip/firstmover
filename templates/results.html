{% extends "layout.html" %}
{% block body %}
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>

  <div class="card">
    <a href="{{ url_for('index') }}" class="btn secondary">← Start over</a>

    <div style="display:flex; gap:16px; flex-wrap:wrap; align-items:center;">
      <div><strong>Composite Percentile:</strong> {{ score if score is not none else 'N/A' }}</div>
      <div>
        <strong>Verified Composite Percentile:</strong>
        {{ score_verified if score_verified is not none else 'N/A' }}
        {% if score_verified is not none %}<span class="pill">✓ verified</span>{% endif %}
      </div>
    </div>

    <h2 style="margin-top:10px;">You average in the top {{ score if score is not none else 'N/A' }}% of early adopters</h2>
    <p class="note" style="margin-top:4px;">Smaller numbers mean earlier adoption. A ✓ next to a value means it's verified from email.</p>
  </div>

  <div class="card">
    <h3>Platforms</h3>

    {% for p in platforms %}
      <div class="platform-row" style="align-items:flex-start;">
        {% if p.logo_url %}
          <img class="platform-logo" src="{{ p.logo_url }}" alt="{{ p.name }} logo" onerror="this.style.display='none'"/>
        {% endif %}

        <div style="flex:1; min-width:260px;">
          <div style="display:flex; justify-content:space-between; align-items:center; gap:8px; flex-wrap:wrap;">
            <div style="display:flex; align-items:center; gap:8px;">
              <strong>{{ p.name }}</strong>
              {% if p.metric_tag %}<span class="pill secondary">{{ p.metric_tag }}</span>{% endif %}
              {% if p.verified %}<span class="pill">✓ verified</span>{% else %}<span class="pill secondary">self-report</span>{% endif %}
            </div>
            {% if p.percentile is not none %}
              <span class="pill">{{ p.percentile }}th percentile</span>
            {% endif %}
          </div>

          <div class="note" style="margin-top:4px;">
            Joined: {{ p.joined }}
            {% if p.email_hint %}<span style="margin-left:8px;">· <em>{{ p.email_hint }}</em></span>{% endif %}
          </div>

          {% if p.joined_users and p.today_users %}
            <p style="margin:8px 0 0 0;">
              You joined {{ p.name }} <strong>{{ p.narrative_after }}</strong> after launch,
              before <strong>{{ p.narrative_percent }}%</strong> of current users.
              When you joined {{ p.name }} it had approximately
              <strong>{{ "{:,}".format(p.joined_users) }}</strong> users compared to
              <strong>{{ "{:,}".format(p.today_users) }}</strong> today.
            </p>
          {% endif %}

          {% if p.chart and p.chart['points_m'] %}
            <div style="margin-top:10px; width:100%;">
              <canvas id="curve-{{ loop.index }}"></canvas>
            </div>
            <script>
              (function(){
                // Expect p.chart.points_m in *millions* with ISO x
                const points = {{ p.chart['points_m']|tojson }};
                const joinISO = "{{ p.join_iso or '' }}";
				const yLabel = "{{ p.y_label or ( (p.metric_tag ~ ' (Millions)') if p.metric_tag else 'Users (Millions)') }}";
                const metricTag = "{{ p.metric_tag or 'Users' }}";
                const ctx = document.getElementById('curve-{{ loop.index }}').getContext('2d');

                if (!points || !points.length) return;

                // Make the x-axis start at the first datum (near launch) and end at the last datum
                const firstX = new Date(points[0].x);
                const lastX  = new Date(points[points.length - 1].x);

                // Proportional y-axis headroom so the last point is visible and matches the text
                const maxY   = points.reduce((m, pt) => Math.max(m, pt.y || 0), 0);
                const niceMax = maxY ? Math.ceil(maxY * 1.1) : undefined;

                const joinMarkerPlugin = {
                  id: 'joinMarker{{ loop.index }}',
                  afterDatasetsDraw(chart) {
                    if (!joinISO) return;
                    const x = chart.scales.x.getPixelForValue(new Date(joinISO));
                    if (!isFinite(x)) return;
                    const { top, bottom } = chart.chartArea;
                    const c = chart.ctx;
                    c.save();
                    c.setLineDash([6,4]);
                    c.lineWidth = 1.5;
                    c.strokeStyle = '#0f172a';{% extends "layout.html" %}
{% block body %}

<!-- Chart.js + date adapter -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>

<style>
  :root { --brand:#0ea5e9; --ink:#0f172a; --muted:#475569; --line:#e2e8f0; --bg:#f8fafc; }
  * { box-sizing:border-box; }
  body { font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
  .container { max-width: 960px; margin: 0 auto; padding: 24px; background: var(--bg); color: var(--ink); }
  .card { background:#fff; border:1px solid var(--line); border-radius:16px; padding:20px; box-shadow:0 2px 10px rgba(0,0,0,0.04); margin-bottom:18px; }
  .btn, .btn:visited { display:inline-flex; align-items:center; justify-content:center; gap:8px; background:var(--brand); color:#fff; padding:10px 14px; border-radius:10px; text-decoration:none; border:none; cursor:pointer; font-weight:600; font-size:15px; line-height:1.2; }
  .btn.secondary { background:#e2e8f0; color:var(--ink); }
  .pill { display:inline-block; background:var(--brand); color:#fff; padding:2px 8px; border-radius:999px; font-size:12px; }
  .pill.secondary { background:#eef2f7; color:#334155; }
  .note { color:var(--muted); font-size:14px; }
  .platform-logo { width: 18px; height: 18px; object-fit: contain; }
  .platform-head { display:flex; justify-content:space-between; align-items:center; gap:8px; flex-wrap:wrap; }
  .chart-wrap { width:100%; height: 280px; margin-top:10px; }
  canvas { background:#fff; border:1px solid var(--line); border-radius:10px; }
</style>

<div class="container">
  <div class="card">
    <a href="/" class="btn secondary">← Start over</a>
    <div style="display:flex; gap:16px; flex-wrap:wrap; align-items:center; margin-top:8px;">
      {% if score is defined %}<div><strong>Composite Percentile:</strong> {{ '%.1f'|format(score) }}</div>{% endif %}
      {% if score_verified is defined %}
        <div>
          <strong>Verified Composite Percentile:</strong>
          {{ '%.1f'|format(score_verified) }}
          <span class="pill">✓ verified</span>
        </div>
      {% endif %}
    </div>
    {% if score is defined %}
      <h2 style="margin-top:10px;">You average in the top {{ '%.1f'|format(score) }}% of early adopters</h2>
      <p class="note" style="margin-top:4px;">Smaller numbers mean earlier adoption. A ✓ next to a value means it's verified from email.</p>
    {% endif %}
  </div>

  <!-- One clean card per platform -->
  {% for p in platforms %}
    <div class="card">
      <div style="display:flex; align-items:flex-start; gap:12px;">
        {% if p.logo_url %}
          <img class="platform-logo" src="{{ p.logo_url }}" alt="{{ p.name }} logo" onerror="this.style.display='none'"/>
        {% endif %}

        <div style="flex:1; min-width:260px;">
          <div class="platform-head">
            <div style="display:flex; align-items:center; gap:8px;">
              <strong>{{ p.name }}</strong>
              {% if p.metric_tag %}<span class="pill secondary">{{ p.metric_tag }}</span>{% endif %}
              {% if p.verified %}<span class="pill">✓ verified</span>{% endif %}
            </div>
            {% if p.percentile is not none %}
              <span class="pill">{{ '%.1f'|format(p.percentile) }}th percentile</span>
            {% endif %}
          </div>

          <div class="note" style="margin-top:4px;">
            {% set joined_human = p.joined_human or p.joined_str or p.joined %}
            {% if joined_human %}Joined: {{ joined_human }}{% endif %}
            {% set email_hint = p.email_found_human or p.email_found_str %}
            {% if email_hint %}<span style="margin-left:8px;">· <em>Also found in email: {{ email_hint }}</em></span>{% endif %}
          </div>

          {% if p.narrative %}
            <p style="margin:8px 0 0 0;">{{ p.narrative|safe }}</p>
          {% else %}
            {% if p.after_launch_human and p.percentile is not none and p.joined_users and p.today_users %}
              <p style="margin:8px 0 0 0;">
                You joined {{ p.name }} <strong>{{ p.after_launch_human }}</strong> after launch,
                before <strong>{{ '%.1f'|format(100.0 - (100.0 - p.percentile)) if false else (100 - p.percentile)|int ~ '%.0f' }}</strong> of current users.
                When you joined {{ p.name }} it had approximately
                <strong>{{ '{:,}'.format(p.joined_users|int) }}</strong> users compared to
                <strong>{{ '{:,}'.format(p.today_users|int) }}</strong> today.
              </p>
            {% endif %}
          {% endif %}

          {% set has_points = p.chart and p.chart.points_m %}
          {% if has_points %}
            <div class="chart-wrap">
              <canvas id="curve-{{ loop.index }}"></canvas>
            </div>
            <script>
              (function(){
                // Expect: points = [{x:'YYYY-MM-DD', y:<millions>}] extracted server-side from adoption_curves
                const points = {{ p.chart.points_m | tojson }};
                const joinISO   = "{{ p.join_iso or p.joined_iso or '' }}";
                const launchISO = "{{ p.launch_iso or '' }}";
                const yLabel    = "{{ p.y_label or (p.metric_tag ~ ' (Millions)') or 'Users (Millions)' }}";
                const metricTag = "{{ p.metric_tag or 'Users' }}";
                const ctx = document.getElementById('curve-{{ loop.index }}').getContext('2d');

                if (!points || !points.length) return;

                // Axis bounds: start x-axis at launch date if available; otherwise first point
                const firstX = new Date(points[0].x);
                const lastX  = new Date(points[points.length - 1].x);
                const xMin   = launchISO ? new Date(launchISO) : firstX;  // ← ensures axis begins at launch

                // Headroom on Y so last label doesn't clip
                const maxY = points.reduce((m, pt) => Math.max(m, pt.y || 0), 0);
                const niceMax = maxY ? Math.ceil(maxY * 1.1) : undefined;

                // Join-date vertical marker
                const joinMarkerPlugin = {
                  id: 'joinMarker{{ loop.index }}',
                  afterDatasetsDraw(chart) {
                    if (!joinISO) return;
                    const x = chart.scales.x.getPixelForValue(new Date(joinISO));
                    if (!isFinite(x)) return;
                    const { top, bottom } = chart.chartArea;
                    const c = chart.ctx;
                    c.save();
                    c.setLineDash([6,4]);
                    c.lineWidth = 1.5;
                    c.strokeStyle = '#0f172a';
                    c.beginPath();
                    c.moveTo(x, top);
                    c.lineTo(x, bottom);
                    c.stroke();
                    // arrow at top
                    c.setLineDash([]);
                    c.fillStyle = '#0f172a';
                    c.beginPath();
                    c.moveTo(x, top);
                    c.lineTo(x - 6, top + 12);
                    c.lineTo(x + 6, top + 12);
                    c.closePath();
                    c.fill();
                    c.restore();
                  }
                };

                new Chart(ctx, {
                  type: 'line',
                  data: {
                    datasets: [{
                      label: metricTag + ' (Millions)',
                      data: points,
                      parsing: { xAxisKey: 'x', yAxisKey: 'y' },
                      fill: false,
                      tension: 0.15,
                      spanGaps: true,
                      borderWidth: 2.25,
                      pointRadius: 2.5
                    }]
                  },
                  options: {
                    maintainAspectRatio: false, // use .chart-wrap height
                    animation: false,
                    plugins: {
                      legend: { display: false },
                      tooltip: {
                        callbacks: {
                          label: (ctx)=> `${metricTag}: ${Intl.NumberFormat().format(ctx.parsed.y)}M`
                        }
                      }
                    },
                    scales: {
                      x: {
                        type: 'time',
                        min: xMin,     // ← launch date (if provided)
                        max: lastX,
                        time: { unit: 'year', tooltipFormat: 'MMM d, yyyy' },
                        title: { display: true, text: 'Year' },
                        ticks: { maxRotation: 0 }
                      },
                      y: {
                        beginAtZero: true,
                        suggestedMax: niceMax,
                        title: { display: true, text: yLabel }
                      }
                    }
                  },
                  plugins: [joinMarkerPlugin]
                });
              })();
            </script>
          {% endif %}
        </div>
      </div>
    </div>
  {% endfor %}

  <!-- Summary bar chart at the bottom -->
  <div class="card">
    <canvas id="barChart"></canvas>
  </div>

  <script>
    // Build arrays from server context
    const labels = {{ chart_labels | tojson | default('[]', true) }};
    const dataVals = {{ chart_values | tojson | default('[]', true) }};
    const verifiedFlags = {{ chart_verified | tojson | default('[]', true) }};
    const verifiedComposite = {{ score_verified if score_verified is defined else 'null' }};

    // Map label -> logo URL for axis icons
    const labelToLogo = {};
    {% for p in platforms %}
      {% if p.name and p.logo_url %}
        labelToLogo[{{ p.name|tojson }}] = {{ p.logo_url|tojson }};
      {% endif %}
    {% endfor %}

    const ctxBar = document.getElementById('barChart').getContext('2d');

    // Preload logos
    const logoImgs = {};
    labels?.forEach(l => {
      const url = labelToLogo[l];
      if (!url) return;
      const img = new Image();
      img.src = url;
      logoImgs[l] = img;
    });

    // Dashed line at verified composite
    const verifiedLine = {
      id: 'verifiedLine',
      beforeDatasetsDraw(chart) {
        if (verifiedComposite === null || verifiedComposite === undefined) return;
        const y = chart.scales.y.getPixelForValue(verifiedComposite);
        if (!isFinite(y)) return;
        const { left, right } = chart.chartArea;
        const c = chart.ctx;
        c.save();
        c.setLineDash([6,4]);
        c.lineWidth = 1.5;
        c.strokeStyle = '#0f172a';
        c.beginPath();
        c.moveTo(left, y);
        c.lineTo(right, y);
        c.stroke();
        c.restore();
      }
    };

    // Value bubbles above each bar
    const barLabels = {
      id: 'barLabels',
      afterDatasetsDraw(chart) {
        const { ctx, scales: { x, y }, data } = chart;
        const vals = data.datasets[0].data || [];
        vals.forEach((val, i) => {
          if (val == null) return;
          const xPos = x.getPixelForValue(i);
          const yTop = y.getPixelForValue(val);
          const text = (verifiedFlags?.[i] ? '✓ ' : '') + val + 'th';
          ctx.save();
          ctx.font = '600 13px Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
          const metrics = ctx.measureText(text);
          const paddingX = 8, paddingY = 5, boxH = 20;
          const boxW = metrics.width + paddingX*2;
          const rectX = Math.round(xPos - boxW/2);
          const rectY = Math.round(yTop - boxH - 6);
          ctx.fillStyle = 'rgba(255,255,255,0.98)';
          const r = 10;
          ctx.beginPath();
          ctx.moveTo(rectX + r, rectY);
          ctx.lineTo(rectX + boxW - r, rectY);
          ctx.quadraticCurveTo(rectX + boxW, rectY, rectX + boxW, rectY + r);
          ctx.lineTo(rectX + boxW, rectY + boxH - r);
          ctx.quadraticCurveTo(rectX + boxW, rectY + boxH, rectX + boxW - r, rectY + boxH);
          ctx.lineTo(rectX + r, rectY + boxH);
          ctx.quadraticCurveTo(rectX, rectY + boxH, rectX, rectY + boxH - r);
          ctx.lineTo(rectX, rectY + r);
          ctx.quadraticCurveTo(rectX, rectY, rectX + r, rectY);
          ctx.closePath();
          ctx.fill();
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillStyle = '#0f172a';
          ctx.fillText(text, Math.round(xPos), Math.round(rectY + boxH/2));
          ctx.restore();
        });
      }
    };

    // Tiny logos under x-axis tick labels
    const xLogos = {
      id: 'xLogos',
      afterDraw(chart) {
        const { ctx, scales: { x }, chartArea } = chart;
        const bottom = chartArea.bottom;
        const offset = 38; // extra space below tick labels
        (labels || []).forEach((label, i) => {
          const img = logoImgs[label];
          if (!img || !img.complete) return;
          const xPos = x.getPixelForValue(i);
          const size = 22;
          ctx.save();
          ctx.drawImage(img, Math.round(xPos - size/2), Math.round(bottom + offset), size, size);
          ctx.restore();
        });
      }
    };

    new Chart(ctxBar, {
      type: 'bar',
      data: {
        labels,
        datasets: [{
          label: 'Early-adopter Percentile (lower is earlier)',
          data: dataVals,
          borderWidth: 0,
          backgroundColor: 'rgba(37, 99, 235, 0.35)'
        }]
      },
      options: {
        layout: { padding: { bottom: 92 } },
        plugins: { legend: { display: false } },
        scales: {
          y: { beginAtZero: true, max: 100, title: { display: true, text: 'Percentile' }, ticks: { precision: 0 } },
          x: { title: { display: true, text: 'Platform', padding: { top: 46 } }, ticks: { padding: 12 } }
        }
      },
      plugins: [verifiedLine, barLabels, xLogos]
    });
  </script>
</div>
{% endblock %}

                    c.beginPath();
                    c.moveTo(x, top);
                    c.lineTo(x, bottom);
                    c.stroke();
                    // arrow head
                    c.setLineDash([]);
                    c.fillStyle = '#0f172a';
                    c.beginPath();
                    c.moveTo(x, top);
                    c.lineTo(x - 6, top + 12);
                    c.lineTo(x + 6, top + 12);
                    c.closePath();
                    c.fill();
                    c.restore();
                  }
                };

                new Chart(ctx, {
                  type: 'line',
                  data: {
                    datasets: [{
                      label: metricTag + ' (Millions)',
                      data: points,
                      parsing: { xAxisKey: 'x', yAxisKey: 'y' },
                      fill: false,
                      tension: 0.15,
                      spanGaps: true,
                      borderWidth: 2.25,
                      pointRadius: 2.5
                    }]
                  },
                  options: {
                    maintainAspectRatio: false,
                    plugins: {
                      legend: { display: false },
                      tooltip: {
                        callbacks: {
                          label: (ctx)=> `${metricTag}: ${Intl.NumberFormat().format(ctx.parsed.y)}M`
                        }
                      }
                    },
                    scales: {
                      x: {
                        type: 'time',
                        min: firstX,
                        max: lastX,
                        time: { unit: 'year', tooltipFormat: 'MMM d, yyyy' },
                        title: { display: true, text: 'Year' },
                        ticks: { maxRotation: 0 }
                      },
                      y: {
                        beginAtZero: true,
                        suggestedMax: niceMax,
                        title: { display: true, text: yLabel }
                      }
                    }
                  },
                  plugins: [joinMarkerPlugin]
                });
              })();
            </script>
          {% endif %}
        </div>
      </div>

      {% if not loop.last %}
        <hr style="border:none;border-top:1px dashed var(--line); margin:12px 0;">
      {% endif %}
    {% endfor %}
  </div>

  <!-- Bar chart moved to bottom (like the older, cleaner output) -->
  <div class="card">
    <canvas id="barChart"></canvas>
  </div>

  <script>
    // ---- Bar chart (percentiles) ----
    const labels = {{ chart_labels|tojson }};
    const dataVals = {{ chart_values|tojson }};
    const verifiedFlags = {{ chart_verified|tojson }};
    const verifiedComposite = {{ score_verified if score_verified is not none else 'null' }};

    // Map label -> logo URL (from the platform list above)
    const labelToLogo = {};
    {% for p in platforms %}
      {% if p.logo_url %} labelToLogo["{{ p.name }}"] = "{{ p.logo_url }}"; {% endif %}
    {% endfor %}

    const ctxBar = document.getElementById('barChart').getContext('2d');

    // Preload logos
    const logoImgs = {};
    labels.forEach(l => {
      const url = labelToLogo[l];
      if (!url) return;
      const img = new Image();
      img.src = url;
      logoImgs[l] = img;
    });

    // Verified dashed line (drawn before bars)
    const verifiedLine = {
      id: 'verifiedLine',
      beforeDatasetsDraw(chart) {
        if (verifiedComposite === null || verifiedComposite === undefined) return;
        const y = chart.scales.y.getPixelForValue(verifiedComposite);
        if (!isFinite(y)) return;
        const { left, right } = chart.chartArea;
        const c = chart.ctx;
        c.save();
        c.setLineDash([6,4]);
        c.lineWidth = 1.5;
        c.strokeStyle = '#0f172a';
        c.beginPath();
        c.moveTo(left, y);
        c.lineTo(right, y);
        c.stroke();
        c.restore();
      }
    };

    // Value “pills” above each bar (drawn after datasets)
    const barLabels = {
      id: 'barLabels',
      afterDatasetsDraw(chart) {
        const { ctx, scales: { x, y }, data } = chart;
        const vals = data.datasets[0].data;
        vals.forEach((val, i) => {
          if (val == null) return;
          const xPos = x.getPixelForValue(i);
          const yTop = y.getPixelForValue(val);

          const text = (verifiedFlags[i] ? '✓ ' : '') + val + 'th';
          ctx.save();
          ctx.font = '600 13px Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
          const metrics = ctx.measureText(text);
          const boxW = metrics.width + 16;
          const boxH = 20;
          const rectX = Math.round(xPos - boxW/2);
          const rectY = Math.round(yTop - boxH - 6);

          ctx.fillStyle = 'rgba(255,255,255,0.98)';
          const r = 10;
          ctx.beginPath();
          ctx.moveTo(rectX + r, rectY);
          ctx.lineTo(rectX + boxW - r, rectY);
          ctx.quadraticCurveTo(rectX + boxW, rectY, rectX + boxW, rectY + r);
          ctx.lineTo(rectX + boxW, rectY + boxH - r);
          ctx.quadraticCurveTo(rectX + boxW, rectY + boxH, rectX + boxW - r, rectY + boxH);
          ctx.lineTo(rectX + r, rectY + boxH);
          ctx.quadraticCurveTo(rectX, rectY + boxH, rectX, rectY + boxH - r);
          ctx.lineTo(rectX, rectY + r);
          ctx.quadraticCurveTo(rectX, rectY, rectX + r, rectY);
          ctx.closePath();
          ctx.fill();

          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillStyle = '#0f172a';
          ctx.fillText(text, Math.round(xPos), Math.round(rectY + boxH/2));
          ctx.restore();
        });
      }
    };

    // Logos under tick labels with generous bottom padding
    const xLogos = {
      id: 'xLogos',
      afterDraw(chart) {
        const { ctx, scales: { x }, chartArea } = chart;
        const bottom = chartArea.bottom;
        const offset = 38;     // gives the labels room
        const size = 22;       // crisp but not crowded
        labels.forEach((label, i) => {
          const img = logoImgs[label];
          if (!img || !img.complete) return;
          const xPos = x.getPixelForValue(i);
          ctx.save();
          ctx.drawImage(img, Math.round(xPos - size/2), Math.round(bottom + offset), size, size);
          ctx.restore();
        });
      }
    };

    new Chart(ctxBar, {
      type: 'bar',
      data: {
        labels,
        datasets: [{
          label: 'Early-adopter Percentile (lower is earlier)',
          data: dataVals,
          borderWidth: 0,
          backgroundColor: 'rgba(37, 99, 235, 0.35)'
        }]
      },
      options: {
        layout: { padding: { bottom: 92 } },   // space for tick labels + logos + x title
        plugins: { legend: { display: false } },
        scales: {
          y: { beginAtZero: true, max: 100, title: { display: true, text: 'Percentile' }, ticks: { precision: 0 } },
          x: { title: { display: true, text: 'Platform', padding: { top: 46 } }, ticks: { padding: 12 } }
        }
      },
      plugins: [verifiedLine, barLabels, xLogos]
    });
  </script>
{% endblock %}
